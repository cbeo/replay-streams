* =replay-streams=

=replay-streams= let the programmer rewind and replay an input stream, providing
input streams with a kind of look-ahead.

The implementation uses [[https://github.com/trivial-gray-streams/trivial-gray-streams][trivial-gray-streams]] under the cheese, and so
=replay-streams= are supported in the most common of Common Lisps.

** Basic Use

The most basic function exported by =replay-streams= is the =replay-on=
function, which transforms an input stream into a "replayable stream". Right now
*only character streams* are supported, but extending support to byte-oriented
streams is on the +haruspectic+ to-do list below.  

A brief catalog of exports:

+ =replay-character-stream= is the *class* for replayable chracter streams.
  - =(make-instance 'replay-character-stream :source (make-string-input-stream "Hey"))=
  - Or, more conveniently using =replay-on=:  =(replay-on (make-string-input-stream "Hey"))=
+ =rewind= is a =defgeneric= that is currently only implemented for
  =replay-character-stream=, its purpose is to rewind the stream. A stream may
  only be rewound once.
+ =rewound-p= a predictate that tests whether or not a stream as been rewound yet.
+ =replay-finished-p= a predicate that returns =T= if the rewound content has all
  been read through again. That is, you rewind at some point, you can then
  replay back to that point. =replay-finished-p= returns =T= if you've passed
  that point from which you initially rewound.
+ =recover-source= returns the source input stream. 


*** Example

#+begin_src common-lisp

CL-USER> (ql:quickload 'replay-streams)    ;; NOT IN QUICKLISP. Install into quicklisp/local-projects/
To load "replay-streams":
  Load 1 ASDF system:
    replay-streams
; Loading "replay-streams"
[package replay-streams]
(REPLAY-STREAMS)

CL-USER> (use-package :replay-streams)
T

CL-USER> (defvar *source* (make-string-input-stream "Hey there here is a string!"))
*SOURCE*

CL-USER> (defvar *rpstream* (make-instance 'replay-character-stream 
                                           :source *source*))
                                           
CL-USER> (let ((buf (make-string 10)))
           (read-sequence buf *rpstream*)
           buf)
"Hey there "

CL-USER> (let ((buf (make-string 10)))
           (read-sequence buf *rpstream*)
           buf)
"here is a "

CL-USER> (rewind *rpstream*)      ;; rewind returns two values, the stream and a success indicator
#<SB-IMPL::STRING-INPUT-STREAM {10042D0F83}>
T

CL-USER> (let ((buf (make-string 10)))
           (read-sequence buf *rpstream*)
           buf)
"Hey there "

CL-USER> (let ((buf (make-string 10)))
           (read-sequence buf *rpstream*)
           buf)
"here is a "

CL-USER> (let ((buf (make-string 10)))
           (read-sequence buf *rpstream*)
           buf)
"string!^@^@^@"

CL-USER> (rewind *rpstream*)       ;; YOU CAN ONLY REWIND ONCE
#<SB-IMPL::STRING-INPUT-STREAM {10042D0F83}>
NIL

#+end_src

** [1/3] Haruspectic Divination

- [X] Support =stream-unread-char= for =replay-character-stream= 
- [ ] Extend support to byte-oriented streams
- [ ] Add Test Suite

